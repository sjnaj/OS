#include <stdio.h>  
  
int main()  
{  
    int a=1, b=2, c=0;  
  
    asm(  
        "addl %2, %0"       // 1  c=a,c=c+b
        : "=g"(c)           // 2  
        : "0"(a), "g"(b)    // 3  初始化操作数0为a的值，b分配一个寄存器
        : "memory");        // 4  表明内存可能被修改，防止优化
  
    printf("现在c是:%d\n", c);  
    return 0;  
}  
// 第1行是汇编语句，用双引号引起来， 多条语句用 ; 或者 \n\t 来分隔。
// 第2行是输出操作数，都是 "=?"(var) 的形式， var 可以是任意内存变量（输出结果会存到这个变量中）， ? 一般是下面这些标识符（表示内联汇编中用什么来代理这个操作数）：

// a,b,c,d,S,D 分别代表 eax,ebx,ecx,edx,esi,edi 寄存器
// r 上面的寄存器的任意一个（谁闲着就用谁）
// m 内存
// i 立即数（常量，只用于输入操作数）
// g 寄存器、内存、立即数 都行（gcc你看着办）
// 在汇编中用 %序号 来代表这些输入/输出操作数，序号从 0 开始。为了与操作数区分开来，寄存器用两个%引出，如：%%eax
// 具体的编号规则为：若命令共涉及n个操作数，则第1个输出操作数（the first output operand）被编号为0，第2个output operand编号为1，依次类推，最后1个输入操作数（the last input operand）则被编号为n-1。
// 第3行是输入操作数，都是 "?"(var) 的形式， ? 除了可以是上面的那些标识符，还可以是输出操作数的序号，表示用 var 来初始化该输出操作数，上面的程序中 %0 和 %1 就是一个东西，初始化为 1（a的值）。
// 第4行标出那些在汇编代码中修改了的、又没有在输入/输出列表中列出的寄存器(clobber list)，这样 gcc 就不会擅自使用这些"危险的"寄存器。还可以用 "memory" 表示在内联汇编中修改了内存，之前缓存在寄存器中的内存变量需要重新读取。